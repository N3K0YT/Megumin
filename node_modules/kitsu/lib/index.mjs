import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import axios from 'axios';
import pluralise from 'pluralize';
import { camel, snake, kebab, query, deserialise, error, serialise } from 'kitsu-core/lib/index.mjs';

class Kitsu {
  constructor() {
    let options = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
    this.camel = !1 === options.camelCaseTypes ? s => s : camel, this.resCase = 'none' === options.resourceCase ? s => s : 'snake' === options.resourceCase ? snake : kebab, this.plural = !1 === options.pluralize ? s => s : pluralise, this.headers = Object.assign({}, options.headers, {
      Accept: 'application/vnd.api+json',
      "Content-Type": 'application/vnd.api+json'
    }), this.axios = axios.create({
      baseURL: options.baseURL || 'https://kitsu.io/api/edge',
      timeout: options.timeout || 30000
    }), this.fetch = this.get, this.update = this.patch, this.create = this.post, this.remove = this.delete;
  }

  async get(model) {
    let params = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
        headers = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};

    try {
      let _model$split = model.split('/'),
          _model$split2 = _slicedToArray(_model$split, 3),
          res = _model$split2[0],
          id = _model$split2[1],
          relationship = _model$split2[2],
          url = this.plural(this.resCase(res));

      id && (url += "/".concat(id)), relationship && (url += "/".concat(this.resCase(relationship)));

      const _ref = await this.axios.get(url, {
        params,
        paramsSerializer: p => query(p),
        headers: Object.assign(this.headers, headers)
      }),
            data = _ref.data;

      return deserialise(data);
    } catch (E) {
      throw error(E);
    }
  }

  async patch(model, body) {
    let headers = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};

    try {
      const serialData = await serialise.apply(this, [model, body, 'PATCH']),
            url = this.plural(this.resCase(model)) + '/' + body.id,
            _ref2 = await this.axios.patch(url, serialData, {
        headers: Object.assign(this.headers, headers)
      }),
            data = _ref2.data;

      return data;
    } catch (E) {
      throw error(E);
    }
  }

  async post(model, body) {
    let headers = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};

    try {
      const url = this.plural(this.resCase(model)),
            _ref3 = await this.axios.post(url, (await serialise.apply(this, [model, body])), {
        headers: Object.assign(this.headers, headers)
      }),
            data = _ref3.data;

      return data;
    } catch (E) {
      throw error(E);
    }
  }

  async delete(model, id) {
    let headers = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};

    try {
      const url = this.plural(this.resCase(model)) + '/' + id,
            _ref4 = await this.axios.delete(url, {
        data: await serialise.apply(this, [model, {
          id
        }, 'DELETE']),
        headers: Object.assign(this.headers, headers)
      }),
            data = _ref4.data;

      return data;
    } catch (E) {
      throw error(E);
    }
  }

  async self() {
    let params = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {},
        headers = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};

    try {
      const res = await this.get('users', Object.assign({
        filter: {
          self: !0
        }
      }, params), headers);
      return res.data[0];
    } catch (E) {
      throw error(E);
    }
  }

}

export default Kitsu;
